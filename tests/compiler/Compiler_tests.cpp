#include "../../src/Compiler.h"
#include "catch.hpp"
#include <algorithm> // for std::sort
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

#ifndef SNAPSHOT_TESTS_DIR
#error "SNAPSHOT_TESTS_DIR is not defined. Please configure it in your CMakeLists.txt"
#endif

namespace fs = std::filesystem;

namespace
{
std::string ReadFile(const fs::path& path)
{
	std::ifstream file(path, std::ios::in | std::ios::binary);
	if (!file)
	{
		throw std::runtime_error("Cannot open file: " + path.string());
	}
	return { std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>() };
}

void WriteFile(const fs::path& path, const std::string& content)
{
	fs::create_directories(path.parent_path());
	std::ofstream file(path);
	if (!file)
	{
		throw std::runtime_error("Cannot open file for writing: " + path.string());
	}
	file << content;
}

std::vector<fs::path> GetTestFiles(const fs::path& directory)
{
	std::vector<fs::path> files;
	for (const auto& entry : fs::directory_iterator(directory))
	{
		if (entry.is_regular_file())
		{
			files.push_back(entry.path());
		}
	}
	std::sort(files.begin(), files.end());
	return files;
}

std::string Trim(const std::string& str)
{
	const auto first = str.find_first_not_of(" \t\n\r");
	if (std::string::npos == first)
	{
		return str;
	}
	const auto last = str.find_last_not_of(" \t\n\r");
	return str.substr(first, (last - first + 1));
}

} // namespace

namespace
{
/**
 * 1. To update snapshots, set the UPDATE_SNAPSHOTS value to true
 * 2. Do not commit with UPDATE_SNAPSHOTS = true
 * 3. Before updating snapshots, check them manually
 */
const bool UPDATE_SNAPSHOTS = false;

void AssertResultMatchesSnapshot(std::string const& result, fs::path const& snapshotFile)
{
	if (UPDATE_SNAPSHOTS)
	{
		WriteFile(snapshotFile, result);
		FAIL("Snapshot generated/updated for " + snapshotFile.filename().string());
		return;
	}

	REQUIRE(fs::exists(snapshotFile));
	const std::string expectedByteCode = ReadFile(snapshotFile);
	THEN("the generated bytecode should match the snapshot")
	{
		CHECK(result == expectedByteCode);
	}
}
} // namespace

SCENARIO("Compiler snapshot tests (Positive cases)")
{
	GIVEN("A compiler and a set of positive test cases")
	{
		Compiler compiler("grammar.gfx");

		const fs::path snapshotTestDir = SNAPSHOT_TESTS_DIR;
		const fs::path codesDir = "codes";
		const fs::path snapshotsDir = "snapshots";

		const auto testFiles = GetTestFiles(snapshotTestDir / codesDir);
		REQUIRE_FALSE(testFiles.empty());

		for (const auto& codeFile : testFiles)
		{
			WHEN("compiling '" + codeFile.filename().string() + "'")
			{
				auto snapshotFile = snapshotTestDir / snapshotsDir / codeFile.filename();
				snapshotFile.replace_extension(".prmbc.snapshot");

				const std::string sourceCode = ReadFile(codeFile);

				std::istringstream input(sourceCode);
				std::ostringstream output;
				compiler.Compile(input, output);

				AssertResultMatchesSnapshot(output.str(), snapshotFile);
			}
		}
	}
}

SCENARIO("Compiler snapshot tests (Negative cases)")
{
	GIVEN("A compiler and a set of negative test cases")
	{
		Compiler compiler("grammar.gfx");

		const fs::path snapshotTestDir = SNAPSHOT_TESTS_DIR;
		const fs::path codesDir = "codes/negative";
		const fs::path snapshotsDir = "snapshots/negative";

		const auto testFiles = GetTestFiles(snapshotTestDir / codesDir);

		for (const auto& codeFile : testFiles)
		{
			WHEN("compiling '" + codeFile.filename().string() + "' which should fail")
			{
				auto snapshotFile = snapshotTestDir / snapshotsDir / codeFile.filename();
				snapshotFile.replace_extension(".prmbc.snapshot");

				const std::string sourceCode = ReadFile(codeFile);

				std::istringstream input(sourceCode);
				std::ostringstream output;

				try
				{
					compiler.Compile(input, output);
				}
				catch (std::exception const& e)
				{
					AssertResultMatchesSnapshot(Trim(e.what()), snapshotFile);
				}
			}
		}
	}
}